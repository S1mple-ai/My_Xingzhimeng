# 星之梦手作管理系统 - 架构优化建议

## 🎯 优化目标

基于对现有系统的深入分析，本文档提供了系统架构、代码质量、性能和用户体验等方面的优化建议，旨在提升系统的可维护性、扩展性和用户体验。

## 🏗️ 架构层面优化

### 1. 配置管理优化

#### 当前问题
- 硬编码配置项分散在各个文件中
- 数据库连接、UI样式、业务规则等配置混合在代码中
- 难以进行环境切换和配置管理

#### 优化方案
```python
# config.py
import os
from dataclasses import dataclass
from typing import Dict, Any

@dataclass
class DatabaseConfig:
    db_path: str = "handmade_shop.db"
    backup_path: str = "backups"
    auto_backup: bool = True

@dataclass
class UIConfig:
    page_title: str = "星之梦手作管理系统"
    page_icon: str = "🏪"
    theme_colors: Dict[str, str] = None
    
    def __post_init__(self):
        if self.theme_colors is None:
            self.theme_colors = {
                "primary": "#2E86AB",
                "secondary": "#A23B72",
                "accent": "#F18F01",
                "success": "#06D6A0",
                "warning": "#FFD23F",
                "error": "#F72585"
            }

@dataclass
class BusinessConfig:
    points_per_yuan: int = 1
    low_stock_threshold: int = 5
    page_size_options: list = None
    
    def __post_init__(self):
        if self.page_size_options is None:
            self.page_size_options = [10, 20, 50]

class Config:
    def __init__(self):
        self.database = DatabaseConfig()
        self.ui = UIConfig()
        self.business = BusinessConfig()
        
    @classmethod
    def from_env(cls):
        """从环境变量加载配置"""
        config = cls()
        config.database.db_path = os.getenv("DB_PATH", config.database.db_path)
        config.business.points_per_yuan = int(os.getenv("POINTS_PER_YUAN", config.business.points_per_yuan))
        return config
```

### 2. 服务层架构重构

#### 当前问题
- 业务逻辑与UI逻辑耦合
- DatabaseManager承担过多职责
- 缺少业务服务层抽象

#### 优化方案
```python
# services/base_service.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional

class BaseService(ABC):
    def __init__(self, db_manager):
        self.db = db_manager
    
    @abstractmethod
    def validate_data(self, data: Dict[str, Any]) -> bool:
        pass

# services/customer_service.py
class CustomerService(BaseService):
    def create_customer(self, customer_data: Dict[str, Any]) -> Optional[int]:
        """创建客户，包含业务验证"""
        if not self.validate_data(customer_data):
            raise ValueError("客户数据验证失败")
        
        # 检查手机号重复
        if self.is_phone_exists(customer_data['phone_suffix']):
            raise ValueError("手机号已存在")
        
        return self.db.add_customer(**customer_data)
    
    def validate_data(self, data: Dict[str, Any]) -> bool:
        required_fields = ['nickname', 'phone_suffix']
        return all(field in data and data[field] for field in required_fields)
    
    def is_phone_exists(self, phone_suffix: str) -> bool:
        customers = self.db.get_customers()
        return any(c['phone_suffix'] == phone_suffix for c in customers)
    
    def update_points(self, customer_id: int, points_change: int, reason: str = ""):
        """更新客户积分，记录变更原因"""
        # 记录积分变更历史
        self.db.add_points_history(customer_id, points_change, reason)
        return self.db.update_customer_points(customer_id, points_change)

# services/order_service.py
class OrderService(BaseService):
    def __init__(self, db_manager, customer_service, inventory_service):
        super().__init__(db_manager)
        self.customer_service = customer_service
        self.inventory_service = inventory_service
    
    def create_order(self, order_data: Dict[str, Any]) -> int:
        """创建订单，处理库存扣减和积分更新"""
        if not self.validate_data(order_data):
            raise ValueError("订单数据验证失败")
        
        # 检查库存
        for item in order_data['items']:
            if item['type'] == '现货':
                if not self.inventory_service.check_stock(item['inventory_id'], item['quantity']):
                    raise ValueError(f"库存不足: {item['name']}")
        
        # 创建订单（事务处理）
        with self.db.transaction():
            order_id = self.db.add_order(
                order_data['customer_id'],
                order_data['total_amount'],
                order_data.get('notes', ''),
                order_data.get('image_path', '')
            )
            
            # 添加订单项并扣减库存
            for item in order_data['items']:
                self.db.add_order_item(order_id, **item)
                if item['type'] == '现货':
                    self.inventory_service.reduce_stock(item['inventory_id'], item['quantity'])
            
            # 更新客户积分
            points_earned = int(order_data['total_amount'])
            self.customer_service.update_points(
                order_data['customer_id'], 
                points_earned, 
                f"订单支付 #{order_id}"
            )
        
        return order_id
```

### 3. 数据访问层优化

#### 当前问题
- SQL语句分散在各个方法中
- 缺少连接池管理
- 没有查询优化机制

#### 优化方案
```python
# database/connection_manager.py
import sqlite3
import threading
from contextlib import contextmanager
from typing import Generator

class ConnectionManager:
    def __init__(self, db_path: str, max_connections: int = 10):
        self.db_path = db_path
        self.max_connections = max_connections
        self._local = threading.local()
    
    def get_connection(self) -> sqlite3.Connection:
        if not hasattr(self._local, 'connection'):
            self._local.connection = sqlite3.connect(
                self.db_path, 
                check_same_thread=False
            )
            self._local.connection.row_factory = sqlite3.Row
        return self._local.connection
    
    @contextmanager
    def transaction(self) -> Generator[sqlite3.Connection, None, None]:
        conn = self.get_connection()
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise

# database/queries.py
class Queries:
    # 客户相关查询
    GET_CUSTOMERS = """
        SELECT id, nickname, phone_suffix, points, notes, created_at, updated_at
        FROM customers 
        ORDER BY created_at DESC
    """
    
    GET_CUSTOMER_BY_ID = """
        SELECT * FROM customers WHERE id = ?
    """
    
    # 订单相关查询
    GET_ORDERS_WITH_CUSTOMER = """
        SELECT o.*, c.nickname as customer_name
        FROM orders o
        LEFT JOIN customers c ON o.customer_id = c.id
        WHERE 1=1
        {filters}
        ORDER BY o.created_at DESC
        LIMIT ? OFFSET ?
    """
    
    # 库存相关查询
    GET_LOW_STOCK_ITEMS = """
        SELECT * FROM inventory 
        WHERE quantity <= ?
        ORDER BY quantity ASC
    """

# database/repository.py
class BaseRepository:
    def __init__(self, connection_manager: ConnectionManager):
        self.conn_manager = connection_manager
    
    def execute_query(self, query: str, params: tuple = ()) -> List[sqlite3.Row]:
        conn = self.conn_manager.get_connection()
        cursor = conn.cursor()
        cursor.execute(query, params)
        return cursor.fetchall()
    
    def execute_insert(self, query: str, params: tuple = ()) -> int:
        conn = self.conn_manager.get_connection()
        cursor = conn.cursor()
        cursor.execute(query, params)
        conn.commit()
        return cursor.lastrowid

class CustomerRepository(BaseRepository):
    def get_all(self) -> List[Dict]:
        rows = self.execute_query(Queries.GET_CUSTOMERS)
        return [dict(row) for row in rows]
    
    def get_by_id(self, customer_id: int) -> Optional[Dict]:
        rows = self.execute_query(Queries.GET_CUSTOMER_BY_ID, (customer_id,))
        return dict(rows[0]) if rows else None
```

## 🚀 性能优化建议

### 1. 数据库性能优化

#### 索引优化
```sql
-- 为常用查询字段添加索引
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_customers_phone_suffix ON customers(phone_suffix);
CREATE INDEX idx_inventory_quantity ON inventory(quantity);

-- 复合索引
CREATE INDEX idx_orders_status_date ON orders(status, created_at);
CREATE INDEX idx_order_items_type_inventory ON order_items(item_type, inventory_id);
```

#### 查询优化
```python
# 批量查询优化
class OptimizedQueries:
    @staticmethod
    def get_orders_with_items_batch(order_ids: List[int]) -> Dict:
        """批量获取订单及其商品信息"""
        placeholders = ','.join(['?' for _ in order_ids])
        query = f"""
            SELECT 
                o.*,
                c.nickname as customer_name,
                oi.id as item_id,
                oi.item_type,
                oi.quantity,
                oi.unit_price,
                i.product_name as inventory_name,
                bt.name as bag_type_name,
                f1.name as outer_fabric_name,
                f2.name as inner_fabric_name
            FROM orders o
            LEFT JOIN customers c ON o.customer_id = c.id
            LEFT JOIN order_items oi ON o.id = oi.order_id
            LEFT JOIN inventory i ON oi.inventory_id = i.id
            LEFT JOIN bag_types bt ON oi.bag_type_id = bt.id
            LEFT JOIN fabrics f1 ON oi.outer_fabric_id = f1.id
            LEFT JOIN fabrics f2 ON oi.inner_fabric_id = f2.id
            WHERE o.id IN ({placeholders})
            ORDER BY o.id, oi.id
        """
        return query, order_ids
```

### 2. 缓存策略优化

#### 多层缓存架构
```python
# cache/cache_manager.py
import time
from typing import Any, Optional, Dict
from functools import wraps

class CacheManager:
    def __init__(self):
        self._cache: Dict[str, Dict] = {}
        self._ttl: Dict[str, float] = {}
    
    def get(self, key: str) -> Optional[Any]:
        if key in self._cache:
            if key in self._ttl and time.time() > self._ttl[key]:
                del self._cache[key]
                del self._ttl[key]
                return None
            return self._cache[key]['data']
        return None
    
    def set(self, key: str, value: Any, ttl: int = 300):
        self._cache[key] = {'data': value}
        if ttl > 0:
            self._ttl[key] = time.time() + ttl
    
    def invalidate(self, pattern: str = None):
        if pattern:
            keys_to_remove = [k for k in self._cache.keys() if pattern in k]
            for key in keys_to_remove:
                self._cache.pop(key, None)
                self._ttl.pop(key, None)
        else:
            self._cache.clear()
            self._ttl.clear()

def cached(ttl: int = 300, key_prefix: str = ""):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            cache_key = f"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            cached_result = cache_manager.get(cache_key)
            if cached_result is not None:
                return cached_result
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache_manager.set(cache_key, result, ttl)
            return result
        return wrapper
    return decorator

# 使用示例
cache_manager = CacheManager()

class CustomerService:
    @cached(ttl=600, key_prefix="customers")
    def get_customers(self):
        return self.db.get_customers()
    
    def update_customer(self, customer_id: int, **kwargs):
        result = self.db.update_customer(customer_id, **kwargs)
        # 清除相关缓存
        cache_manager.invalidate("customers")
        return result
```

### 3. 前端性能优化

#### 组件懒加载
```python
# ui/lazy_components.py
import streamlit as st
from typing import Callable, Any

class LazyComponent:
    def __init__(self, loader: Callable, *args, **kwargs):
        self.loader = loader
        self.args = args
        self.kwargs = kwargs
        self._loaded = False
        self._component = None
    
    def render(self):
        if not self._loaded:
            with st.spinner("加载中..."):
                self._component = self.loader(*self.args, **self.kwargs)
                self._loaded = True
        return self._component

# 使用示例
def load_order_chart():
    # 复杂的图表生成逻辑
    orders = get_orders()
    return create_order_trend_chart(orders)

# 在页面中使用
if st.button("显示订单趋势"):
    chart_component = LazyComponent(load_order_chart)
    chart_component.render()
```

## 🔧 代码质量优化

### 1. 错误处理和日志系统

#### 统一异常处理
```python
# exceptions.py
class BusinessException(Exception):
    def __init__(self, message: str, error_code: str = None):
        self.message = message
        self.error_code = error_code
        super().__init__(self.message)

class ValidationError(BusinessException):
    pass

class InsufficientStockError(BusinessException):
    pass

class CustomerNotFoundError(BusinessException):
    pass

# logging_config.py
import logging
import sys
from datetime import datetime

def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(f'logs/app_{datetime.now().strftime("%Y%m%d")}.log'),
            logging.StreamHandler(sys.stdout)
        ]
    )

# 使用装饰器统一处理异常
def handle_exceptions(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except BusinessException as e:
            logging.error(f"业务异常: {e.message}")
            st.error(f"操作失败: {e.message}")
        except Exception as e:
            logging.exception(f"系统异常: {str(e)}")
            st.error("系统错误，请联系管理员")
    return wrapper
```

### 2. 数据验证框架

#### Pydantic模型验证
```python
# models/validators.py
from pydantic import BaseModel, validator, Field
from typing import Optional, List
from datetime import datetime

class CustomerModel(BaseModel):
    nickname: str = Field(..., min_length=1, max_length=50)
    phone_suffix: str = Field(..., regex=r'^\d{4}$')
    points: int = Field(default=0, ge=0)
    notes: Optional[str] = Field(None, max_length=500)
    
    @validator('nickname')
    def nickname_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('客户昵称不能为空')
        return v.strip()

class OrderItemModel(BaseModel):
    item_type: str = Field(..., regex=r'^(现货|定制)$')
    quantity: int = Field(..., gt=0)
    unit_price: float = Field(..., gt=0)
    inventory_id: Optional[int] = None
    bag_type_id: Optional[int] = None
    outer_fabric_id: Optional[int] = None
    inner_fabric_id: Optional[int] = None
    notes: Optional[str] = None
    
    @validator('inventory_id')
    def validate_inventory_for_stock_item(cls, v, values):
        if values.get('item_type') == '现货' and v is None:
            raise ValueError('现货商品必须指定库存ID')
        return v
    
    @validator('bag_type_id')
    def validate_bag_type_for_custom_item(cls, v, values):
        if values.get('item_type') == '定制' and v is None:
            raise ValueError('定制商品必须指定包型ID')
        return v

class OrderModel(BaseModel):
    customer_id: int = Field(..., gt=0)
    items: List[OrderItemModel] = Field(..., min_items=1)
    notes: Optional[str] = Field(None, max_length=1000)
    image_path: Optional[str] = None
    
    @property
    def total_amount(self) -> float:
        return sum(item.quantity * item.unit_price for item in self.items)
```

### 3. 单元测试框架

#### 测试结构
```python
# tests/test_customer_service.py
import pytest
from unittest.mock import Mock, patch
from services.customer_service import CustomerService
from exceptions import ValidationError

class TestCustomerService:
    def setup_method(self):
        self.mock_db = Mock()
        self.customer_service = CustomerService(self.mock_db)
    
    def test_create_customer_success(self):
        # 准备测试数据
        customer_data = {
            'nickname': '测试客户',
            'phone_suffix': '1234',
            'points': 0,
            'notes': '测试备注'
        }
        
        # 模拟数据库返回
        self.mock_db.add_customer.return_value = 1
        self.mock_db.get_customers.return_value = []
        
        # 执行测试
        result = self.customer_service.create_customer(customer_data)
        
        # 验证结果
        assert result == 1
        self.mock_db.add_customer.assert_called_once_with(**customer_data)
    
    def test_create_customer_duplicate_phone(self):
        # 准备测试数据
        customer_data = {
            'nickname': '测试客户',
            'phone_suffix': '1234'
        }
        
        # 模拟已存在的客户
        self.mock_db.get_customers.return_value = [
            {'phone_suffix': '1234'}
        ]
        
        # 执行测试并验证异常
        with pytest.raises(ValueError, match="手机号已存在"):
            self.customer_service.create_customer(customer_data)

# tests/conftest.py
import pytest
import tempfile
import os
from database import DatabaseManager

@pytest.fixture
def temp_db():
    """创建临时数据库用于测试"""
    temp_file = tempfile.NamedTemporaryFile(delete=False)
    temp_file.close()
    
    db = DatabaseManager(temp_file.name)
    yield db
    
    os.unlink(temp_file.name)
```

## 🎨 用户体验优化

### 1. 响应式设计改进

#### 移动端适配
```python
# ui/responsive.py
import streamlit as st

class ResponsiveLayout:
    @staticmethod
    def get_columns_config():
        """根据屏幕尺寸返回列配置"""
        # 检测设备类型（简化版）
        if st.session_state.get('mobile_device', False):
            return [1]  # 移动端单列
        else:
            return [1, 1, 1, 1]  # 桌面端四列
    
    @staticmethod
    def adaptive_columns(*ratios):
        """自适应列布局"""
        if len(ratios) > 2 and st.session_state.get('mobile_device', False):
            # 移动端强制单列
            return [st.container() for _ in range(len(ratios))]
        else:
            return st.columns(ratios)

# 使用示例
def render_dashboard():
    cols = ResponsiveLayout.adaptive_columns(1, 1, 1, 1)
    
    with cols[0]:
        create_metric_card("客户总数", "100")
    with cols[1]:
        create_metric_card("订单总数", "50")
    # ...
```

### 2. 交互体验优化

#### 操作确认和反馈
```python
# ui/feedback.py
import streamlit as st
from typing import Callable, Any

class FeedbackManager:
    @staticmethod
    def confirm_action(message: str, action: Callable, *args, **kwargs) -> Any:
        """确认操作对话框"""
        if f"confirm_{hash(message)}" not in st.session_state:
            st.session_state[f"confirm_{hash(message)}"] = False
        
        if not st.session_state[f"confirm_{hash(message)}"]:
            st.warning(message)
            col1, col2 = st.columns(2)
            with col1:
                if st.button("确认", key=f"confirm_yes_{hash(message)}"):
                    st.session_state[f"confirm_{hash(message)}"] = True
                    st.rerun()
            with col2:
                if st.button("取消", key=f"confirm_no_{hash(message)}"):
                    return None
        else:
            # 执行操作
            try:
                result = action(*args, **kwargs)
                st.success("操作成功完成")
                st.session_state[f"confirm_{hash(message)}"] = False
                return result
            except Exception as e:
                st.error(f"操作失败: {str(e)}")
                st.session_state[f"confirm_{hash(message)}"] = False
                return None

    @staticmethod
    def progress_action(message: str, action: Callable, steps: int = 100) -> Any:
        """带进度条的操作"""
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        try:
            for i in range(steps):
                progress_bar.progress((i + 1) / steps)
                status_text.text(f"{message}... {i+1}/{steps}")
                # 这里可以添加实际的步骤逻辑
            
            result = action()
            status_text.text("操作完成!")
            return result
        except Exception as e:
            status_text.text(f"操作失败: {str(e)}")
            raise
```

### 3. 数据可视化增强

#### 交互式图表
```python
# visualization/charts.py
import plotly.graph_objects as go
import plotly.express as px
from typing import List, Dict

class EnhancedCharts:
    @staticmethod
    def create_interactive_order_trend(orders: List[Dict]):
        """创建交互式订单趋势图"""
        df = pd.DataFrame(orders)
        df['created_at'] = pd.to_datetime(df['created_at'])
        df['date'] = df['created_at'].dt.date
        
        daily_stats = df.groupby('date').agg({
            'id': 'count',
            'total_amount': 'sum'
        }).reset_index()
        
        fig = go.Figure()
        
        # 添加订单数量线
        fig.add_trace(go.Scatter(
            x=daily_stats['date'],
            y=daily_stats['id'],
            mode='lines+markers',
            name='订单数量',
            line=dict(color='#2E86AB', width=3),
            hovertemplate='日期: %{x}<br>订单数量: %{y}<extra></extra>'
        ))
        
        # 添加销售额线（次坐标轴）
        fig.add_trace(go.Scatter(
            x=daily_stats['date'],
            y=daily_stats['total_amount'],
            mode='lines+markers',
            name='销售额',
            yaxis='y2',
            line=dict(color='#A23B72', width=3),
            hovertemplate='日期: %{x}<br>销售额: ¥%{y:.2f}<extra></extra>'
        ))
        
        # 更新布局
        fig.update_layout(
            title='订单趋势分析',
            xaxis_title='日期',
            yaxis=dict(title='订单数量', side='left'),
            yaxis2=dict(title='销售额 (¥)', side='right', overlaying='y'),
            hovermode='x unified',
            template='plotly_white'
        )
        
        return fig
    
    @staticmethod
    def create_customer_analysis_chart(customers: List[Dict]):
        """创建客户分析图表"""
        df = pd.DataFrame(customers)
        
        # 积分分布
        fig_points = px.histogram(
            df, 
            x='points', 
            nbins=20,
            title='客户积分分布',
            labels={'points': '积分', 'count': '客户数量'}
        )
        
        return fig_points
```

## 📱 移动端优化

### 1. PWA支持
```python
# pwa/manifest.py
def generate_pwa_manifest():
    return {
        "name": "星之梦手作管理系统",
        "short_name": "星之梦",
        "description": "手作业务管理系统",
        "start_url": "/",
        "display": "standalone",
        "background_color": "#ffffff",
        "theme_color": "#2E86AB",
        "icons": [
            {
                "src": "static/icon-192.png",
                "sizes": "192x192",
                "type": "image/png"
            },
            {
                "src": "static/icon-512.png",
                "sizes": "512x512",
                "type": "image/png"
            }
        ]
    }
```

### 2. 离线支持
```python
# offline/cache_strategy.py
class OfflineManager:
    def __init__(self):
        self.offline_data = {}
    
    def cache_critical_data(self):
        """缓存关键数据以支持离线使用"""
        self.offline_data = {
            'customers': self.get_customers(),
            'inventory': self.get_inventory_items(),
            'bag_types': self.get_bag_types(),
            'fabrics': self.get_fabrics()
        }
    
    def sync_when_online(self):
        """网络恢复时同步数据"""
        # 实现数据同步逻辑
        pass
```

## 🔒 安全性增强

### 1. 数据加密
```python
# security/encryption.py
import hashlib
import secrets
from cryptography.fernet import Fernet

class DataEncryption:
    def __init__(self):
        self.key = self._get_or_create_key()
        self.cipher = Fernet(self.key)
    
    def _get_or_create_key(self):
        """获取或创建加密密钥"""
        key_file = "config/encryption.key"
        try:
            with open(key_file, 'rb') as f:
                return f.read()
        except FileNotFoundError:
            key = Fernet.generate_key()
            with open(key_file, 'wb') as f:
                f.write(key)
            return key
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """加密敏感数据"""
        return self.cipher.encrypt(data.encode()).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """解密敏感数据"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()
```

### 2. 访问控制
```python
# security/auth.py
import streamlit as st
from typing import Optional

class SimpleAuth:
    def __init__(self, password_hash: str):
        self.password_hash = password_hash
    
    def authenticate(self, password: str) -> bool:
        """简单密码验证"""
        return hashlib.sha256(password.encode()).hexdigest() == self.password_hash
    
    def require_auth(self):
        """要求用户认证"""
        if 'authenticated' not in st.session_state:
            st.session_state.authenticated = False
        
        if not st.session_state.authenticated:
            st.title("🔐 系统登录")
            password = st.text_input("请输入密码", type="password")
            
            if st.button("登录"):
                if self.authenticate(password):
                    st.session_state.authenticated = True
                    st.success("登录成功!")
                    st.rerun()
                else:
                    st.error("密码错误!")
            
            st.stop()
```

## 📊 监控和分析

### 1. 性能监控
```python
# monitoring/performance.py
import time
import functools
from typing import Dict, List

class PerformanceMonitor:
    def __init__(self):
        self.metrics: Dict[str, List[float]] = {}
    
    def measure_time(self, func_name: str = None):
        """性能测量装饰器"""
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                start_time = time.time()
                result = func(*args, **kwargs)
                end_time = time.time()
                
                execution_time = end_time - start_time
                metric_name = func_name or func.__name__
                
                if metric_name not in self.metrics:
                    self.metrics[metric_name] = []
                
                self.metrics[metric_name].append(execution_time)
                
                # 记录慢查询
                if execution_time > 1.0:  # 超过1秒
                    logging.warning(f"慢操作检测: {metric_name} 耗时 {execution_time:.2f}秒")
                
                return result
            return wrapper
        return decorator
    
    def get_performance_report(self) -> Dict:
        """获取性能报告"""
        report = {}
        for func_name, times in self.metrics.items():
            report[func_name] = {
                'count': len(times),
                'avg_time': sum(times) / len(times),
                'max_time': max(times),
                'min_time': min(times)
            }
        return report
```

### 2. 业务分析
```python
# analytics/business_analytics.py
class BusinessAnalytics:
    def __init__(self, db_manager):
        self.db = db_manager
    
    def get_customer_insights(self) -> Dict:
        """客户洞察分析"""
        customers = self.db.get_customers()
        orders = self.db.get_orders()
        
        # 客户价值分析
        customer_value = {}
        for order in orders:
            customer_id = order['customer_id']
            if customer_id not in customer_value:
                customer_value[customer_id] = 0
            customer_value[customer_id] += order['total_amount']
        
        # 客户分层
        high_value = [cid for cid, value in customer_value.items() if value > 1000]
        medium_value = [cid for cid, value in customer_value.items() if 500 <= value <= 1000]
        low_value = [cid for cid, value in customer_value.items() if value < 500]
        
        return {
            'total_customers': len(customers),
            'high_value_customers': len(high_value),
            'medium_value_customers': len(medium_value),
            'low_value_customers': len(low_value),
            'avg_customer_value': sum(customer_value.values()) / len(customer_value) if customer_value else 0
        }
    
    def get_product_insights(self) -> Dict:
        """产品洞察分析"""
        # 实现产品销售分析
        pass
    
    def get_trend_analysis(self) -> Dict:
        """趋势分析"""
        # 实现趋势分析
        pass
```

## 🚀 部署和运维优化

### 1. Docker化部署
```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8501

HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health

CMD ["streamlit", "run", "main.py", "--server.port=8501", "--server.address=0.0.0.0"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8501:8501"
    volumes:
      - ./data:/app/data
      - ./backups:/app/backups
    environment:
      - DB_PATH=/app/data/handmade_shop.db
    restart: unless-stopped
    
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app
    restart: unless-stopped
```

### 2. 自动化运维
```python
# ops/health_check.py
import requests
import time
import logging

class HealthChecker:
    def __init__(self, app_url: str):
        self.app_url = app_url
    
    def check_health(self) -> bool:
        """健康检查"""
        try:
            response = requests.get(f"{self.app_url}/_stcore/health", timeout=5)
            return response.status_code == 200
        except Exception as e:
            logging.error(f"健康检查失败: {e}")
            return False
    
    def monitor_continuously(self, interval: int = 60):
        """持续监控"""
        while True:
            if not self.check_health():
                logging.error("应用健康检查失败，需要人工介入")
                # 发送告警通知
                self.send_alert()
            
            time.sleep(interval)
    
    def send_alert(self):
        """发送告警"""
        # 实现告警逻辑（邮件、短信、钉钉等）
        pass
```

## 📋 实施建议

### 优先级排序
1. **高优先级**
   - 配置管理优化
   - 服务层架构重构
   - 数据验证框架
   - 错误处理和日志系统

2. **中优先级**
   - 性能优化（缓存、索引）
   - 单元测试框架
   - 用户体验优化
   - 安全性增强

3. **低优先级**
   - PWA支持
   - 高级分析功能
   - Docker化部署
   - 自动化运维

### 实施步骤
1. **第一阶段（1-2周）**: 配置管理和服务层重构
2. **第二阶段（2-3周）**: 数据验证和错误处理
3. **第三阶段（3-4周）**: 性能优化和测试框架
4. **第四阶段（4-6周）**: 用户体验和安全性优化
5. **第五阶段（6-8周）**: 部署和运维优化

### 风险评估
- **技术风险**: 重构可能引入新的bug，建议分步实施
- **业务风险**: 优化期间可能影响正常使用，建议在低峰期进行
- **资源风险**: 需要投入额外的开发和测试时间

## 🎯 总结

通过以上优化建议的实施，系统将在以下方面得到显著提升：

1. **可维护性**: 清晰的架构分层和模块化设计
2. **可扩展性**: 灵活的配置管理和服务化架构
3. **性能**: 多层缓存和数据库优化
4. **用户体验**: 响应式设计和交互优化
5. **安全性**: 数据加密和访问控制
6. **稳定性**: 完善的错误处理和监控机制

建议按照优先级逐步实施这些优化方案，确保系统在保持稳定运行的同时不断改进和完善。